// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: products.sql

package schema

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const createProduct = `-- name: CreateProduct :one
insert into products (id, creator, name, description, usage, category, price, price_discount, details, tags)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
returning id, creator, category, name, description, usage, price, price_discount, ts, created_at, updated_at, details, tags
`

type CreateProductParams struct {
	ID            int64         `json:"id"`
	Creator       int64         `json:"creator"`
	Name          string        `json:"name"`
	Description   string        `json:"description"`
	Usage         string        `json:"usage"`
	Category      string        `json:"category"`
	Price         int32         `json:"price"`
	PriceDiscount sql.NullInt32 `json:"price_discount"`
	Details       string        `json:"details"`
	Tags          []string      `json:"tags"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (*Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.ID,
		arg.Creator,
		arg.Name,
		arg.Description,
		arg.Usage,
		arg.Category,
		arg.Price,
		arg.PriceDiscount,
		arg.Details,
		pq.Array(arg.Tags),
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Creator,
		&i.Category,
		&i.Name,
		&i.Description,
		&i.Usage,
		&i.Price,
		&i.PriceDiscount,
		&i.Ts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Details,
		pq.Array(&i.Tags),
	)
	return &i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
delete
from products
where id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getProductById = `-- name: GetProductById :one
select products.id, products.creator, products.category, products.name, products.description, products.usage, products.price, products.price_discount, products.ts, products.created_at, products.updated_at, products.details, products.tags, u.id, u.nickname, u.permissions, u.created_at, u.updated_at, u.cash, count(pu)
from products
         left join public.users u on u.id = products.creator
         left join public.purchases pu on pu.product = products.id
where products.id = $1
group by products.id, u.id, pu.product
`

type GetProductByIdRow struct {
	Product Product `json:"product"`
	User    User    `json:"user"`
	Count   int64   `json:"count"`
}

func (q *Queries) GetProductById(ctx context.Context, id int64) (*GetProductByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getProductById, id)
	var i GetProductByIdRow
	err := row.Scan(
		&i.Product.ID,
		&i.Product.Creator,
		&i.Product.Category,
		&i.Product.Name,
		&i.Product.Description,
		&i.Product.Usage,
		&i.Product.Price,
		&i.Product.PriceDiscount,
		&i.Product.Ts,
		&i.Product.CreatedAt,
		&i.Product.UpdatedAt,
		&i.Product.Details,
		pq.Array(&i.Product.Tags),
		&i.User.ID,
		&i.User.Nickname,
		&i.User.Permissions,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Cash,
		&i.Count,
	)
	return &i, err
}

const listProducts = `-- name: ListProducts :many
select products.id, products.creator, products.category, products.name, products.description, products.usage, products.price, products.price_discount, products.ts, products.created_at, products.updated_at, products.details, products.tags, u.id, u.nickname, u.permissions, u.created_at, u.updated_at, u.cash, count(pu)
from products
         left join public.users u on u.id = products.creator
         left join public.purchases pu on pu.product = products.id
where products.id > $1::int
group by products.id, products.created_at, u.id, pu.product
order by products.created_at desc
limit $2
`

type ListProductsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListProductsRow struct {
	Product Product `json:"product"`
	User    User    `json:"user"`
	Count   int64   `json:"count"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]*ListProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProducts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.Product.ID,
			&i.Product.Creator,
			&i.Product.Category,
			&i.Product.Name,
			&i.Product.Description,
			&i.Product.Usage,
			&i.Product.Price,
			&i.Product.PriceDiscount,
			&i.Product.Ts,
			&i.Product.CreatedAt,
			&i.Product.UpdatedAt,
			&i.Product.Details,
			pq.Array(&i.Product.Tags),
			&i.User.ID,
			&i.User.Nickname,
			&i.User.Permissions,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Cash,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
update products
set creator        = coalesce($2, creator),
    name           = coalesce($3, name),
    description    = coalesce($4, description),
    usage          = coalesce($5, usage),
    details        = coalesce($6, details),
    category       = coalesce($7, category),
    tags           = coalesce($8, tags),
    price          = coalesce($9, price),
    price_discount = coalesce($10, price_discount),
		updated_at = now()
where id = $1
returning id, creator, category, name, description, usage, price, price_discount, ts, created_at, updated_at, details, tags
`

type UpdateProductParams struct {
	ID            int64          `json:"id"`
	Creator       sql.NullInt64  `json:"creator"`
	Name          sql.NullString `json:"name"`
	Description   sql.NullString `json:"description"`
	Usage         sql.NullString `json:"usage"`
	Details       sql.NullString `json:"details"`
	Category      sql.NullString `json:"category"`
	Tags          []string       `json:"tags"`
	Price         sql.NullInt32  `json:"price"`
	PriceDiscount sql.NullInt32  `json:"price_discount"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (*Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ID,
		arg.Creator,
		arg.Name,
		arg.Description,
		arg.Usage,
		arg.Details,
		arg.Category,
		pq.Array(arg.Tags),
		arg.Price,
		arg.PriceDiscount,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Creator,
		&i.Category,
		&i.Name,
		&i.Description,
		&i.Usage,
		&i.Price,
		&i.PriceDiscount,
		&i.Ts,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Details,
		pq.Array(&i.Tags),
	)
	return &i, err
}
