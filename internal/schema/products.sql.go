// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: products.sql

package schema

import (
	"context"
	"database/sql"
)

const createProduct = `-- name: CreateProduct :one
insert into products (id, creator, name, description, usage, category, price)
values ($1, $2, $3, $4, $5, $6, $7)
returning id, creator, category, name, description, usage, price, price_discount, ts, created_at, updated_at
`

type CreateProductParams struct {
	ID          int64          `json:"id"`
	Creator     int64          `json:"creator"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Usage       sql.NullString `json:"usage"`
	Category    string         `json:"category"`
	Price       int32          `json:"price"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (*Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.ID,
		arg.Creator,
		arg.Name,
		arg.Description,
		arg.Usage,
		arg.Category,
		arg.Price,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Creator,
		&i.Category,
		&i.Name,
		&i.Description,
		&i.Usage,
		&i.Price,
		&i.PriceDiscount,
		&i.Ts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
delete
from products
where id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getProductById = `-- name: GetProductById :one
select products.id, products.creator, products.category, products.name, products.description, products.usage, products.price, products.price_discount, products.ts, products.created_at, products.updated_at, u.id, u.nickname, u.permissions, u.created_at, u.updated_at, u.cash, count(pu)
from products
         left join public.users u on u.id = products.creator
         left join public.purchases pu on pu.product = products.id
where products.id = $1
group by products.id, u.id, pu.product
`

type GetProductByIdRow struct {
	Product Product `json:"product"`
	User    User    `json:"user"`
	Count   int64   `json:"count"`
}

func (q *Queries) GetProductById(ctx context.Context, id int64) (*GetProductByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getProductById, id)
	var i GetProductByIdRow
	err := row.Scan(
		&i.Product.ID,
		&i.Product.Creator,
		&i.Product.Category,
		&i.Product.Name,
		&i.Product.Description,
		&i.Product.Usage,
		&i.Product.Price,
		&i.Product.PriceDiscount,
		&i.Product.Ts,
		&i.Product.CreatedAt,
		&i.Product.UpdatedAt,
		&i.User.ID,
		&i.User.Nickname,
		&i.User.Permissions,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Cash,
		&i.Count,
	)
	return &i, err
}

const listProducts = `-- name: ListProducts :many
select products.id, products.creator, products.category, products.name, products.description, products.usage, products.price, products.price_discount, products.ts, products.created_at, products.updated_at, u.id, u.nickname, u.permissions, u.created_at, u.updated_at, u.cash, count(pu)
from products
         left join public.users u on u.id = products.creator
         left join public.purchases pu on pu.product = products.id
where products.id > $1::int
group by products.id, products.created_at, u.id, pu.product
order by products.created_at desc
limit $2
`

type ListProductsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListProductsRow struct {
	Product Product `json:"product"`
	User    User    `json:"user"`
	Count   int64   `json:"count"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]*ListProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProducts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.Product.ID,
			&i.Product.Creator,
			&i.Product.Category,
			&i.Product.Name,
			&i.Product.Description,
			&i.Product.Usage,
			&i.Product.Price,
			&i.Product.PriceDiscount,
			&i.Product.Ts,
			&i.Product.CreatedAt,
			&i.Product.UpdatedAt,
			&i.User.ID,
			&i.User.Nickname,
			&i.User.Permissions,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Cash,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
update products
set creator     = coalesce($2, creator),
    name        = coalesce($3, name),
    description = coalesce($4, description),
    usage       = coalesce($5, usage),
    category    = coalesce($6, category),
    price       = coalesce($7, price)
where id = $1
returning id, creator, category, name, description, usage, price, price_discount, ts, created_at, updated_at
`

type UpdateProductParams struct {
	ID          int64          `json:"id"`
	Creator     sql.NullInt64  `json:"creator"`
	Name        sql.NullString `json:"name"`
	Description sql.NullString `json:"description"`
	Usage       sql.NullString `json:"usage"`
	Category    sql.NullString `json:"category"`
	Price       sql.NullInt32  `json:"price"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (*Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ID,
		arg.Creator,
		arg.Name,
		arg.Description,
		arg.Usage,
		arg.Category,
		arg.Price,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Creator,
		&i.Category,
		&i.Name,
		&i.Description,
		&i.Usage,
		&i.Price,
		&i.PriceDiscount,
		&i.Ts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
